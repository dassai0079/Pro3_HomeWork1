# 実装メモ

## キー入力方針

- ターミナルの設定を取得
    - tcgetattr(int fd, struct termios termios_p);
        - ``` tcgetattr() は fd に関するパラメーターを取得し、termios_p が参照する構 造体 termios に設定する。 ```
        - int fd:   ファイル記述子(ファイルディスクリプタ)を表す値。標準入力は0 (https://ja.wikipedia.org/wiki/ファイル記述子)   
        => fd=0を指定すると、キー入力に関する設定をいじくることが出来る。
        - struct termios termios_p: termios構造体のポインタ。環境設定をこの関数で取得してtermios構造体型にまとめた後、それをしまうための構造体
    - STDIN_FILENO: 標準入力のファイル記述子

- カノニカルモード離脱
    - カノニカルモード: エンターキーを入力された初めてターミナルがそこまでの入力を読んでくれるモード
    - 標準入力に関する設定構造体(tcgetattrの処理中で設定値をコピーして入れた構造体)の内部値をいじればよい。

    - termios型構造体  
    tcflag_t c_iflag;      /* input modes */  
    tcflag_t c_oflag;      /* output modes */  
    tcflag_t c_cflag;      /* control modes */  
    tcflag_t c_lflag;      /* local modes */   
    cc_t     c_cc[NCCS];   /* special characters */  

    c_iflagをいじると思うじゃん？処理系統全般を担うためのc_lflagをいじらなきゃいけないんだよね。
    じゃないとなぜかカノニカルモードから脱出できない。

    - カノニカルモードを脱出する演算: termiosFoo.c_lflag &= ~ICANON;  
    c_lflag &= ~ICANON: <=何これ  
    tcflag_tは、各**ビット**で処理状態を管理している。
    そして、ICANON は、カノニカルモードを有効にするためのビットマスクである。
    要するに、ICANONは2、すなわち下から2ビット目だけが1で、ほかが1であるint型の数だったが、
    これとc_lflagでANDをとったらカノニカルモードを司るフラグ(ビット)だけが1になって、
    それ以外のビットが0になる。それはいけない。  
    じゃあどうするか？=>カノニカルモードを司るフラグ(ビット)だけを0にして、それ意外はキープしよう。  
    ところで、論理演算ではa AND 1 = aであった。
    これを逆手に取る。ICANONを反転させる（=補数をとる）と、カノニカルモードを司るビットが0に、それ以外は**全て**1になる。その値とc_lflagのANDをとると、きれいにカノニカルモードを司るビットだけが0になり、それ以外はキープされるというわけさ！！
        - これを応用すると...
        エコーオフにしたい！！ってときは、入力された文字をエコーするかどうかを司るビットのビットマスク、ECHOも反転させればよい。
        ここで、ICANONとECHOのOR（論理和）をとる。すると、その値はエコーするかどうかを司るビットと、カノニカルモードを司るビットの両方に対するビットマスクとなる。  
        =>これとc_lflagのANDをとったら...その両方のビットをいっぺんに反転できて、なおかつ他のビットはそのままに出来る！

    - chatGPT曰く
    ICANON は、POSIX 標準に基づく端末制御のフラグの一つで、カノニカルモードを意味します。このフラグは、端末設定を管理するためのビットマスクの一部として定義されますが、その具体的な値は、システムやライブラリによって異なる場合があります。特に、ICANON はビットフィールドとして扱われるため、その値（ビット位置）は処理系に依存します。
    通常、ICANON は、端末設定の termios 構造体で使われ、フラグが有効な場合に ICANON ビットが 1 になります。このフラグのビット位置や値は、システムによって異なる可能性があります。例えば、あるシステムでは ICANON が 0x00000100（256）で定義されている一方で、別のシステムではその値が異なることもあります。

- termios型構造体のc_ccについて
    これは配列なわけですが...そのインデックス毎に司る値が違うのです。
    例えば、マクロVMINで与えられる値をインデックスに指定すると、その値は非カノニカル読み込み時の最小文字数を司る値であり、これをいじくれば何文字まで入力しなきゃいけないよ、というのが指定できる。

- termiosのリファレンス
    - https://manpages.debian.org/testing/manpages-ja-dev/tcgetattr.3.ja.html
    - Linuxのmanページ ``termios``
    - https://ssr-yuki.hatenablog.com/entry/2019/02/17/024943




